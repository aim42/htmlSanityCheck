var documents = [

{
    "id": 0,
    "uri": "report/report.html",
    "menu": "report",
    "title": "Demo-Report",
    "text": " .td-content>p { max-width: 100% !important; } "
},

{
    "id": 1,
    "uri": "ea/readme.html",
    "menu": "ea",
    "title": "readme.ad",
    "text": " Table of Contents Warning! This folder contains exported diagrams or notes from Enterprise Architect. Please note that these are generated files but reside in the src -folder in order to be versioned. This is to make sure that they can be used from environments other than windows. Warning! The contents of this folder will be overwritten with each re-export! use gradle exportEA to re-export files "
},

{
    "id": 2,
    "uri": "excel/readme.html",
    "menu": "excel",
    "title": "readme.ad",
    "text": " Table of Contents Warning! This folder contains exported workbooks from Excel. Please note that these are generated files but reside in the src -folder in order to be versioned. This is to make sure that they can be used from environments other than windows. Warning! The contents of this folder will be overwritten with each re-export! use gradle exportExcel to re-export files "
},

{
    "id": 3,
    "uri": "development/template.html",
    "menu": "development",
    "title": "Descriptive Title",
    "text": " Table of Contents Descriptive Title Descriptive Title Problem Description Introduce the reader to your problem by describing the current situation and the resulting problem in detail. Use diagrams to visualize the problem. Proposed Approach You already have a solution approach in mind? Describe it here so that it can be discussed. Again, diagrams might be helptful. Decision Document the decision in Detail by moving all information from this Discussion to capter 9 Design Decisions of your arc42 docs. "
},

{
    "id": 4,
    "uri": "development/issue-185.html",
    "menu": "development",
    "title": "Automated Checker Factory",
    "text": " Table of Contents Automated Checker Factory Problem Solution Approach Automated Checker Factory Issue 185 proposes to automatically detect and instantiate Checker (sub-)classes. Problem We want to adhere to the Open-Close principle (OCP) when adding new checkers: There shall be no need to touch other code when writing a new checker, especially should there be no central registry of checkers. Up to v 1.0.0-RC-1 we violated the OCP and allowed major redundancies in code: class AllCheckers { public final static LinkedHashSet&lt;Class&gt; checkerClazzes = [BrokenCrossReferencesChecker, BrokenHttpLinksChecker, DuplicateIdChecker, ImageMapChecker, MissingAltInImageTagsChecker, MissingImageFilesChecker, MissingLocalResourcesChecker].toSet() } Solution Approach A solution needs to address two issues: 1.) find all Checker subclasses One approach here relies on Java annotations, described by Przemysław Wojnowski , and uses the Reflections library. 2.) instantiate these classes (aka Factory for the checkers) "
},

{
    "id": 5,
    "uri": "development/issue-252.html",
    "menu": "development",
    "title": "Issue 252 (MissingLocalResourcesChecker gives false positives)",
    "text": " Table of Contents Issue 252 (MissingLocalResourcesChecker gives false positives) Background Proposed Approach Decision Issue 252 (MissingLocalResourcesChecker gives false positives) Problem Description The MLR-Checker currently gives false positives (false alarms) if the link has a form like &lt;a href=/foo&gt; Background The short form of a URL: &lt;a href=/foo&gt; can actually mean one of the following: /foo.html more generally /foo.&lt;extension&gt; /foo/index.&lt;extension&gt; where extension is one of the following: html, htm, shtml, phtml, php, asp, aspx, xml Proposed Approach Define a proper name for the link without extension ( prefixOnlyHref ) When checking local resources, add a special case for URLs with prefixOnlyHref . Add a new configuration item with the extensions to be checked, the default should be the list given above ( ITEM_NAME_prefixOnlyHrefExtensions ) Add these defaults to NetUtil Decision Document the decision in Detail by moving all information from this Discussion to capter 9 Design Decisions of your arc42 docs. "
},

{
    "id": 6,
    "uri": "development/issue-244.html",
    "menu": "development",
    "title": "Handling 30x Status Codes",
    "text": " Table of Contents Handling 30x Status Codes Proposed Approach Handling 30x Status Codes Issue 244 explains that status codes 30x (redirect of some kind) might signal an error, but can return the new location of the requested resource. For example: (`curl -I performs a HEAD request) &lt;snip&gt; curl -I http://www.arc.de HTTP/1.1 301 Moved Permanently Content-Type: text/html; charset=UTF-8 Connection: keep-alive Keep-Alive: timeout=15 Date: Wed, 24 Oct 2018 14:16:04 GMT Server: Apache X-Powered-By: PHP/7.0.32 Location: https://arc42.de/ &lt;/snip&gt; So - the url exists in principle (in the example above, it only changed from http to https &#8230;&#8203; Proposed Approach A very simple solution would be to access the location header and return that together with the warning message. if (responseCode in [301, 302, 303, 307, 308]) then { // get location String newLocation if (connection.headerFields.'Location') { // add connection.headerFields.Location.first() to warning message } } "
},

{
    "id": 7,
    "uri": "development/issue-190.html",
    "menu": "development",
    "title": "Refactoring the Main Checking Loop",
    "text": " Table of Contents Refactoring the Main Checking Loop Proposed (new) Scenario Refactoring the Main Checking Loop Issue 190 proposes to merge the two classes AllChecksRunner and ChecksRunner. Proposed (new) Scenario "
},

{
    "id": 8,
    "uri": "manual/01_manual.html",
    "menu": "Manual",
    "title": "HTML Sanity Check",
    "text": " Table of Contents Html Sanity Check Installation Usage Examples Typical Output Types of Sanity Checks Technical Documentation Fundamentals Ideas and Origin Development Similar Projects Contributing Licence Html Sanity Check This project provides some basic sanity checking on html files. It can be helpful in case of html generated from e.g. Asciidoctor , Markdown or other formats - as converters usually don&#8217;t check for missing images or broken links. It can be used as Gradle plugin. Standalone Java and graphical UI are planned for future releases. Installation Use the following snippet inside a Gradle build file: build.gradle plugins { id 'org.aim42.htmlSanityCheck' version 'v2.6.7' } OR build.gradle buildscript { repositories { maven { url https://plugins.gradle.org/m2/ } } dependencies { classpath ('gradle.plugin.org.aim42:htmlSanityCheck:v2.6.7') } } apply plugin: 'org.aim42.htmlSanityCheck' Usage The plugin adds a new task named htmlSanityCheck . This task exposes a few properties as part of its configuration: sourceDir (mandatory) directory where the html files are located. Type: File. Default: build/docs . sourceDocuments (optional) an override to process several source files, which may be a subset of all files available in ${sourceDir} . Type: org.gradle.api.file.FileCollection . Defaults to all files in ${sourceDir} whose names end with .html . checkingResultsDir (optional) directory where the checking results written to. Defaults to ${buildDir}/reports/htmlSanityCheck/ junitResultsDir (optional) directory where the results written to in JUnit XML format. JUnit XML can be read by many tools including CI environments. Defaults to ${buildDir}/test-results/htmlchecks/ failOnErrors (optional) if set to true, the build will fail if any error was found in the checked pages. Defaults to false checkerClasses (optional) a set of checker classes to be executed. Defaults to all available checker classes. Examples build.gradle (small example) apply plugin: 'org.aim42.htmlSanityCheck' htmlSanityCheck { sourceDir = new File( $buildDir/docs ) // where to put results of sanityChecks... checkingResultsDir = new File( $buildDir/report/htmlchecks ) // fail build on errors? failOnErrors = true } build.gradle (extensive example) import org.aim42.htmlsanitycheck.check.* buildscript { repositories { maven { url https://plugins.gradle.org/m2/ } jcenter() } } plugins { id 'org.aim42.htmlsanitycheck' version '1.1.1' id 'org.asciidoctor.convert' version '1.5.8' } // ==== path definitions ===== // =========================== // location of AsciiDoc files def asciidocSrcPath = $projectDir/src/asciidoc // location of images used in AsciiDoc documentation def srcImagesPath = $asciidocSrcPath/images // results of asciidoc compilation (HTML) // (input for htmlSanityCheck) // this is the default path for asciidoc-gradle-convert def htmlOutputPath = $buildDir/asciidoc/html5 // images used by generated html def targetImagesPath = htmlOutputPath + /images // where HTMLSanityCheck checking results ares stored def checkingResultsPath = $buildDir/report/htmlchecks apply plugin: 'org.asciidoctor.convert' asciidoctor { sourceDir = new File( asciidocSrcPath ) options backends: ['html5'], doctype: 'book', icons: 'font', sectlink: true, sectanchors: true resources { from( srcImagesPath ) into targetImagesPath } } apply plugin: 'org.aim42.htmlSanityCheck' htmlSanityCheck { // ensure asciidoctor-&gt;html runs first // and images are copied to build directory dependsOn asciidoctor sourceDir = new File( htmlOutputPath ) // files to check, specified as a file tree with filtering sourceDocuments = fileTree(sourceDir) { include many-errors.html, no-errors.html } // where to put results of sanityChecks... checkingResultsDir = new File( checkingResultsPath ) // fail build on errors? failOnErrors = false // http connection timeout in milliseconds httpConnectionTimeout = 1000 // which statuscodes shall be interpreted as warning, error or success // defaults to standard httpWarningCodes = [401] // httpErrorCodes // httpSuccessCodes // only execute a subset of all available checks // available checker: // * BrokenCrossReferencesChecker // * BrokenHttpLinksChecker // * DuplicateIdChecker // * ImageMapChecker // * MissingAltInImageTagsChecker // * MissingImageFilesChecker // * MissingLocalResourcesChecker checkerClasses = [DuplicateIdChecker, MissingImageFilesChecker] } Typical Output The overall goal is to create neat and clear reports, showing eventual errors within HTML files - as shown in the adjoining figure. Types of Sanity Checks Broken Cross References (aka Broken Internal Links) Finds all '&lt;a href=XYZ&gt;' where XYZ is not defined. src/broken.html &lt;a href=#missing&gt;internal anchor&lt;/a&gt; ... &lt;h2 id=missinG&gt;Bookmark-Header&lt;/h2&gt; In this example, the bookmark is misspelled . Use checkerClass BrokenCrossReferencesChecker . Missing Images Files Images, referenced in '&lt;img src=XYZ&#8230;&#8203;' tags, refer to external files. The existence of these files is checked by the plugin. Use checkerClass MissingImageFilesChecker . Multiple Definitions of Bookmarks or ID&#8217;s If any is defined more than once, any anchor linking to it will be confused :-) Use checkerClass DuplicateIdChecker . Missing Local Resources All files (e.g. downloads) referenced from html. Use checkerClass MissingLocalResourcesChecker . Missing Alt-tags in Images Image-tags should contain an alt-attribute that the browser displays when the original image file cannot be found or cannot be rendered. Having alt-attributes is good and defensive style. Use checkerClass MissingAltInImageTagsChecker . Broken HTTP Links The current version (derived from branch 1.0.0-RC-2) contains a simple implementation that identifies errors (status &gt;400) and warnings (status 1xx or 3xx). StatusCodes are configurable ranges (as some people might want some content behind paywalls NOT to result in errors&#8230;&#8203;) Localhost or numerical IP addresses are currently NOT marked as suspicious. Please comment in case you have additional requirements. Use checkerClass BrokenHttpLinksChecker . Other types of external links planned : ftp, ntp or other protocols are currently not checked, but should&#8230;&#8203; Technical Documentation In addition to checking HTML, this project serves as an example for arc42 . Please see our software architecture documentation . Fundamentals This tiny piece rests on incredible groundwork: Jsoup HTML parser and analysis toolkit - robust and easy-to-use. IntelliJ IDEA - my (Gernot) best (programming) friend. Of course, Groovy, Gradle, JUnit and Spockframework. Ideas and Origin The plugin heavily relies on code provided by Gradle . Inspiration on code organization, implementation and testing of the plugin came from the Asciidoctor-Gradle-Plugin by [@AAlmiray]. Code for string similarity calculation by Ralph Rice . Initial implementation, maintenance and documentation by Gernot Starke . Development In case you want to checkout, fork and/or contribute: The documentation is maintained using the awesome docToolchain , created by @rdmueller . After checkout you should execute: git submodule update -i to ensure that the docToolchain submodule is downloaded. Helpful Sources for Development Several sources provided help during development: Gradle guide on writing custom plugins The code4reference tutorial an Gradle custom plugins, part 1 and part 2 . Of course, the JSoup API documentation Similar Projects The gradle-linkchecker-plugin is an (open source) gradle plugin which validates that all links in a local HTML file tree go out to other existing local files or remote web locations. It creates a simple text file report and might be a complement to this HtmlSanityChecker . Benjamin Muschko has created a (go-based) command-line tool to check links, called link verifier Contributing Please report issues or suggestions . Want to improve the plugin: Fork our repository and send a pull request. Licence Currently code is published under the Apache-2.0 licence, documentation under Creative-Commons-Sharealike-4.0. Some day I&#8217;ll unify that :-) Big thanx to Structure-101 for helping us analyze and restructure our code&#8230;&#8203; "
},

{
    "id": 9,
    "uri": "development/publishing.html",
    "menu": "development",
    "title": "Publishing kbd:htmlSC Releases",
    "text": " Table of Contents Publishing kbd:htmlSC Releases Publishing kbd:htmlSC Releases Automating the Upload of a Gradle Plugin Puh - handling Bintray or JCenter is not funny . Handling (Secret) Credentials We use Etienne Studers awesome Gradle-Credentials plugin to allow automatic deployment to public portals (like Bintray, JCenter and/or Gradle-Plugin-Portal) and keep the appropriate passwords/API-keys secret. Brief instructions below - for details see the credentials plugin integrate the plugin in the buildfile get the required credentials from the Bintray website (or wherever you want to publish artifacts) add the required credentials: &gt; gradle addCredentials --key bintrayUserName --value &lt;your-Bintray-username&gt; :addCredentials BUILD SUCCESSFUL &gt; gradle addCredentials --key bintrayApiKey --value &lt;some-long-key&gt; Within the buildfile you can now access these credentials as follows: // include these lines in your build.gradle: println Username :  + credentials.bintrayUserName println Bintray API Key :  + credentials.bintrayApiKey "
},

{
    "id": 10,
    "uri": "development/issue-219.html",
    "menu": "development",
    "title": "Handling 403 and 405 Status Codes",
    "text": " Table of Contents Handling 403 and 405 Status Codes Proposed Approach Handling 403 and 405 Status Codes Issue 219 explains that the naive link checks based upon a http HEAD request sometimes fail, e.g. for links to amazon.com: For example: (`curl -I performs a HEAD request) &lt;snip&gt; curl -I https://www.amazon.de/dp/3446443487 HTTP/2 405 server: Server content-type: text/html;charset=UTF-8 &lt;/snip&gt; This is clearly a false negative , as the URL itself is correct and the page exists. Proposed Approach Reason for this double check is to keep the transmitted data volume low (and performance higher). The general behavior we implement shall be the following ` if (responseCode in successCodes) then return else { // try GET connection.setRequestMethod(GET) int finalResponseCode = connection.getResponseCode() switch (realResponseCode) { case warningCodes: println real warning $responseCode; break case errorCodes: println real error $responseCode; break default: println Error: Unknown or unclassified response code } } "
},

{
    "id": 11,
    "uri": "arc42/chapters/chap-07-Deployment.html",
    "menu": "arc42",
    "title": "Deployment View",
    "text": " Table of Contents 1. Deployment View 1. Deployment View Figure 1. Deployment Table 1. Deployment Node / Artifact Description hsc plugin binary compiled version of HtmlSC , including required dependencies. hsc-development where development of HtmlSC takes place artifact repository ( Bintray ) global public cloud repository for binary artifacts, similar to mavenCentral . HtmlSC binaries are uploaded to this server. hsc user computer where arbitrary documentation takes place with html as output formats. build.gradle Gradle build script configuring (among other things) the HtmlSC plugin to check some documentation . The three nodes ( computers ) shown in Deployment are connected via Internet. Sanity checker will: be bundled as a single jar, be uploaded to the Bintray repository, referencable within a gradle buildfile, provide a main method with parameters and options, so all checks can be called from the command line. "
},

{
    "id": 12,
    "uri": "arc42/chapters/chap-05-BuildingBlocks.html",
    "menu": "arc42",
    "title": "Building Block View",
    "text": " Table of Contents 1. Building Block View 1.1. Whitebox HtmlSanityChecker 1.2. Building Blocks - Level 2 1.3. Building Blocks - Level 3 1. Building Block View 1.1. Whitebox HtmlSanityChecker Rationale We used functional decomposition to separate responsibilities: CheckerCore shall encapsulate checking logic and Html parsing/processing. all kinds of outputs (console, html-file, graphical) shall be handled in a separate component ( Reporter ) Implementation of Gradle specific stuff shall be encapsulated. Contained Blackboxes Table 1. HtmlSanityChecker building blocks HSC Core hsc core: html parsing and sanity checking, configuration, reporting. HSC Gradle Plugin integrates the Gradle build tool with HtmlSC , enabling arbitrary gradle builds to use HtmlSC functionality. HSC Maven Plugin  (planned, not yet implemented) HSC Graphical Interface (planned, not implemented) Interfaces Table 2. HtmlSanityChecker internal interfaces Interface Description usage via shell arc42 user uses a command line shell to call the HtmlSC build system  currently restricted to Gradle: The build system uses HtmlSC as configured in the buildscript. local-file system HtmlSC needs access to several local files, especially the html page to be checked and to the corresponding image directories.  external websites to check external links, HtmlSC needs to access external sites via http HEAD or GET requests. 1.1.1. HSC Core (Blackbox) Intent/Responsibility HSC_Core contains the core functions to perform the various sanity checks. It parses the html file into a DOM-like in-memory representation, which is then used to perform the actual checks. Interfaces Table 3. HSC_Core Interfaces Interface (From-To) Description Command Line Interface &#8594; Checker  Uses the #AllChecksRunner class. Gradle Plugin &#8594; Checker Exposes HtmlSC via a standard Gradle plugin, as described in the Gradle user guide. Files org.aim42.htmlsanitycheck.AllChecksRunner org.aim42.htmlsanitycheck.HtmlSanityCheckGradlePlugin 1.2. Building Blocks - Level 2 1.2.1. HSC-Core (Whitebox) Figure 1. HSC-Core (Whitebox) Rationale This structures follows a strictly functional decomposition: parsing and handling html input checking collecting checking results Contained Blackboxes Table 4. HSC-Core building blocks Checker Abstract class, used in form of the template-pattern. Shall be subclassed for all checking algorithms. AllChecksRunner Facade to the different Checker instances. Provides a (parameter-driven) command-line interface. ResultsCollector (Whitebox) Collects all checking results. Its interface Results is contained in the whitebox description Reporter Reports checking results to either console or an html file. HtmlParser Encapsulates html parsing, provides methods to search within the (parsed) html. Suggester In case of checking issues, suggests alternatives by comparing the faulty element to the one present in the html file. Currently not implemented 1.2.2. Checker and xyzChecker Subclasses The abstract Checker provides a uniform interface ( public void check() ) to different checking algorithms. It is based upon the concept of extensible checking algorithms . 1.3. Building Blocks - Level 3 1.3.1. ResultsCollector (Whitebox) Figure 2. Results Collector (Whitebox) Rationale This structures follows the hierarchy of checks - namely managing results for: a number of pages/documents, containing: a single page, each containing many single checks within a page Contained Blackboxes Table 5. ResultsCollector building blocks Per-Run Results results for potentially many Html pages/documents. Single-Page-Results results for a single page Single-Check-Results results for a single type of check (e.g. missing-images check) Finding a single finding, (e.g. image 'logo.png' missing). Can hold suggestions and (planned for future releases) the responsible html element. Interface Results The Result interface is used by all clients (especially Reporter subclasses, graphical and command-line clients) to access checking results. It consists of three distinct APIs for overall RunResults , single-page results ( PageResults ) and single-check results ( CheckResults ). See the interface definitions below - taken from the Groovy- source code: Interface RunResults public interface RunResults { // returns results for all pages which have been checked public ArrayList&lt;SinglePageResults&gt; getResultsForAllPages() // how many pages were checked in this run? public int nrOfPagesChecked() // how many checks were performed in all? public int nrOfChecksPerformedOnAllPages() // how many findings (errors and issues) were found in all? public int nrOfFindingsOnAllPages() // how long took checking (in milliseconds)? public Long checkingTookHowManyMillis() } Interface PageResults public interface PageResults { // what's the title of this page? public String getPageTitle() // what's the filename and path? public String getPageFileName() public String getPageFilePath() // how many items have been checked? public int nrOfItemsCheckedOnPage() // how many problems were found on this page? public int nrOfFindingsOnPage() // how many different checks have run on this page? public int howManyCheckersHaveRun() } Interface CheckResults public interface CheckResults { // return a description of what is checked // (e.g. Missing Images Checker or Broken Cross-References Checker public String description() // returns all findings/problems found during this check public ArrayList&lt;Finding&gt; getFindings() } "
},

{
    "id": 13,
    "uri": "arc42/chapters/chap-03-Context.html",
    "menu": "arc42",
    "title": "Context",
    "text": " Table of Contents 1. Context 1.1. Business Context 1.2. Deployment Context 1. Context 1.1. Business Context Figure 1. Business Context Table 1. Business Context Neighbor Description user documents software with toolchain that generates html. Wants to ensure that links within this html are valid. build system local html files HtmlSC reads and parses local html files and performs sanity checks within those. local image files HtmlSC checks if linked images exist as (local) files. external web resources HtmlSC can be configured to optionally check for the existence of external web resources. Due to the nature of web systems, this check might need a significant amount of time and might yield invalid results due to network and latency issues. 1.2. Deployment Context The following diagram shows the participating computers ({node}) with their technical connections plus the major {artifact} of HtmlSC , the hsc-plugin-binary. Figure 2. Deployment Context Table 2. Deployment Context Node / Artifact Description {node} hsc-development where development of HtmlSC takes place {artifact} hsc-plugin-binary compiled and packaged version of HtmlSC including required dependencies. {node} artifact repository ( Bintray ) global public cloud repository for binary artifacts, similar to mavenCentral . HtmlSC binaries are uploaded to this server. {node} hsc user computer where arbitrary documentation takes place with html as output formats. {artifact} build.gradle Gradle build script configuring (among other things) the HtmlSC plugin to perform the Html checking. Details see deployment view . "
},

{
    "id": 14,
    "uri": "arc42/chapters/chap-04-SolutionStrategy.html",
    "menu": "arc42",
    "title": "Solution Strategy",
    "text": " Table of Contents 1. Solution Strategy 1. Solution Strategy Implement HtmlSC in Groovy and Java with minimal external dependencies. Wrap this implementation into a Gradle plugin, so it can be used within automated builds. Details are given in the Gradle plugin concept . Apply the template-method-pattern (see e.g. {template-method-url}) to enable: multiple checking algorithms. See the concept for checking algorithms , both HTML (file) and text (console) output. See the reporting concept . "
},

{
    "id": 15,
    "uri": "arc42/chapters/chap-02-Constraints.html",
    "menu": "arc42",
    "title": "Constraints",
    "text": " Table of Contents 1. Constraints 1. Constraints HtmlSC shall be: platform-independent and should run on the major operating systems (Windows&#8482;, Linux, and Mac-OS&#8482;) integrated with the Gradle build tool runnable from the command line developed under a liberal open-source license "
},

{
    "id": 16,
    "uri": "arc42/chapters/chap-09-Decisions.html",
    "menu": "arc42",
    "title": "Design Decisions",
    "text": " Table of Contents 1. Design Decisions 1.1. Checking of external links postponed 1.2. HTML Parsing with jsoup 1.3. String Similarity Checking with Jaro-Winkler-Distance 1. Design Decisions 1.1. Checking of external links postponed In the current {revision} we won&#8217;t check external links. These checks have been postponed to later versions. 1.2. HTML Parsing with jsoup To check HTML we parse it into an internal (DOM-like) representation. For this task we use jsoup HTML parser , an open-source parser without external dependencies. To quote from the jsoup website: jsoup is a Java library for working with real-world HTML. It provides a very convenient API for extracting and manipulating data, using the best of DOM, CSS, and jQuery-like methods. Goals of this decision Check HTML programmatically by using an existing API that provides access and finder methods to the DOM-tree of the file(s) to be checked. Decision Criteria few dependencies, so the HtmlSC binary stays as small as possible. accessor and finder methods to find images, links and link-targets within the DOM tree. Alternatives HTTPUnit: a testing framework for web applications and -sites. Its main focus is web testing and it suffers from a large number of dependencies. jsoup: a plain HTML parser without any dependencies (!) and a rich API to access all HTML elements in DOM-like syntax. Find details on how HtmlSC implements HTML parsing in the HTML encapsulation concept . 1.3. String Similarity Checking with Jaro-Winkler-Distance The small java-string-similarity library (by Ralph Allen Rice) contains implementations of several similarity-calculation algorithms. As it is not available as public binary, we use the sources instead, primarily: net.ricecode.similarity.JaroWinklerStrategyTest net.ricecode.similarity.JaroWinklerStrategy Note The actual implementation of the similarity comparison has been postponed to a later release of HtmlSC "
},

{
    "id": 17,
    "uri": "arc42/chapters/chap-08-Concepts.html",
    "menu": "arc42",
    "title": "Technical and Crosscutting Concepts",
    "text": " Table of Contents 1. Technical and Crosscutting Concepts 1.1. HTML Checking Domain Model 1.2. Gradle Plugin Concept and Development 1.3. Flexible Checking Algorithms 1.4. Encapsulate HTML Parsing 1.5. Flexible Reporting 1. Technical and Crosscutting Concepts 1.1. HTML Checking Domain Model Figure 1. HTML Checking Domain Model Table 1. Domain Model Term Description Anchor Html element to create &#8594;Links. Contains link-target in the form &lt;a href=link-target&gt; Cross Reference Link from one part of the document to another part within the same document. A special form of &#8594;Internal Link, with a &#8594;Link Target in the same document. External Link Link to another page or resource at another domain. Finding Description of a problem found by one &#8594;Checker within the &#8594;Html Page. Html Element HTML pages (documents) are made up by HTML elements .e.g., &lt;a href=link target&gt; , &lt;img src=image.png&gt; and others. See the W3-Consortium Html Page A single chunk of HTML, mostly regarded as a single file. Shall comply to standard HTML syntax. Minimal requirement: Our HTML parser can successfully parse this page. Contains &#8594;Html Elements. Also called Html Document . id Identifier for a specific part of a document, e.g. &lt;h2 id=#someHeader&gt; . Often used to describe &#8594;Link Targets. Internal Link Link to another section of the same page or to another page of the same domain. Also called Local Link . Link Any a reference in the &#8594;Html Page that lets you display or activate another part of this document (&#8594;Internal Link) or another document, image or resource (can be either &#8594;Internal (local) or &#8594;External Link). Every link leads from the Link Source to the Link Target Link Target The target of any &#8594;Link, e.g. heading or any other a part of a &#8594;Html Document, any internal or external resource (identified by URI). Expressed by &#8594;id Local Resource local file, either other Html files or other types (e.g. pdf, docx) Run Result The overall results of checking a number of pages (at least one page). Single Page Result A collection of all checks of a single &#8594;Html Page. URI Universal Resource Identifier. Defined in RFC-2396 . The ultimate source of truth concerning link syntax and semantic. 1.2. Gradle Plugin Concept and Development You should definitely read the original Gradle User Guide on custom plugin development. To enable the required Gradle integration , we implement a lean wrapper as described in the Gradle user guide. class HtmlSanityCheckPlugin implements Plugin&lt;Project&gt; { void apply(Project project) { project.task('htmlSanityCheck', type: HtmlSanityCheckTask, group: 'Check') } } 1.2.1. Directory Structure and Required Files |-htmlSanityCheck | |-src | | |-main | | | |-org | | | | |-aim42 | | | | | |-htmlsanitycheck | | | | | | | ... | | | | | | |-HtmlSanityCheckPlugin.groovy // (1) | | | | | | |-HtmlSanityCheckTask.groovy | | | |-resources | | | | |-META-INF // (2) | | | | | |-gradle-plugins | | | | | | |-htmlSanityCheck.properties // (3) | | |-test | | | |-org | | | | |-aim42 | | | | | |-htmlsanitycheck | | | | | | | ... | | | | | | |-HtmlSanityCheckPluginTest | the actual plugin code: HtmlSanityCheckPlugin.groovy and HtmlSanityCheckTask.groovy groovy files Gradle expects plugin properties in META-INF property file containing the name of the actual implementation class: implementation-class=org.aim42.htmlsanitycheck.HtmlSanityCheckPlugin 1.2.2. Passing Parameters From Buildfile to Plugin To be done 1.2.3. Building the Plugin The plugin code itself is built with gradle. 1.2.4. Uploading to Public Archives 1.2.5. Further Information on Creating Gradle Plugins Although writing plugins is described in the Gradle user guide, a clearly explained sample is given in a Code4Reference tutorial. 1.3. Flexible Checking Algorithms HtmlSC uses the template-method-pattern to enable flexible checking algorithms: The Template Method defines a skeleton of an algorithm in an operation, and defers some steps to subclasses. &#8212; https://sourcemaking.com/design_patterns/template_method We achieve that by defining the skeleton of the checking algorithm in one operation, deferring the specific checking algorithm steps to subclasses. The invariant steps are implemented in the abstract base class, while the variant checking algorithms have to be provided by the subclasses. Template method performCheck /** ** template method for performing a single type of checks on the given @see HtmlPage. * * Prerequisite: pageToCheck has been successfully parsed, * prior to constructing this Checker instance. **/ public SingleCheckResults performCheck( final HtmlPage pageToCheck) { // assert non-null htmlPage assert pageToCheck != null checkingResults = new SingleCheckResults() // description is set by subclasses initCheckingResultsDescription() return check( pageToCheck ) // &lt;1&gt; delegate check() to subclass } Figure 2. Template-Method Overview Table 2. Template Method Component Description Checker abstract base class, containing the template method check() plus the public method performCheck() MissingImageFilesChecker checks if referenced local image files exist MissingImgAltAttributeChecker checks if there are image tags without alt-attributes BrokenCrossReferencesChecker checks if cross references (links referenced within the page) exist DuplicateIdChecker checks if any id has multiple definitions MissingLocalResourcesChecker checks if referenced other resources exist BrokenHttpLinksChecker checks if external links are valid IllegalLinkChecker checks if links do not violate HTML link syntax 1.3.1. MissingImageFilesChecker Addresses requirement R-1 . Checks if image files referenced in &lt;img src=someFile.jpg&gt; really exists on the local file system. The (little) problem with checking images is their path: Consider the following HTML fragment (from the file testme.html): &lt;img src=./images/one-image.jpg&gt; This image file (one-image.jpg) has to be located relative to the directory containing the corresponding HTML file. Therefore the expected absolute path of the one-image.jpg has to be determined from the absolute path of the html file under test. We check for existing files using the usual Java API, but have to do some directory arithmetic to get the absolutePathToImageFile: File f = new File( absolutePathToImageFile ); if(f.exists() &amp;&amp; !f.isDirectory()) 1.3.2. MissingImgAltAttributeChecker Addresses requirement R-6 . Simple syntactic check: iterates over all &lt;img&gt; tags to check if the image has an alt-tag. 1.3.3. BrokenCrossReferencesChecker Addresses requirement R-2 . Cross references are document-internal links where the href=link-target from the html anchor tag has no prefix like +http, https, ftp, telnet, mailto, file and such. Only links with prefix # shall be taken into account, e.g. &lt;a href=#internalLink&gt;. 1.3.4. DuplicateIdChecker Addresses requirement R-4 . Sections, especially headings, can be made link-targets by adding the id=#xyz element, yielding for example html headings like the following example. Problems occur if the same link target is defined several times (also shown below). &lt;h2 id=seealso&gt;First Heading&lt;/h2&gt; &lt;h2 id=seealso&gt;Second Heading&lt;/h2&gt; &lt;a href=#seealso&gt;Duplicate definition - where shall I go now?&lt;/a&gt; 1.3.5. MissingLocalResourcesChecker Addresses requirement R-3 . Current limitations: Does NOT deep-checking of references-with-anchors of the following form: &lt;a href=api/Artifact.html#target&gt;GroupInit&lt;/a&gt; containing both a local (file) reference plus an internal anchor #target See issues #252 (false positives) and #253 (deep links shall be checked) 1.3.6. BrokenHttpLinksChecker Addresses requirement R-9 . Problem here are networking issues, latency and HTTP return codes. This checker is planned, but currently not implemented. 1.3.7. IllegalLinkChecker Addresses requirement R-5 . This checker is planned, but currently not implemented. :jbake-status: draft :jbake-order: -1 :jbake-type: page_toc :jbake-menu: - :jbake-title: Encapsulate HTML Parsing 1.4. Encapsulate HTML Parsing We encapsulate the third-party HTML parser ( https://jsoup.org ) in simple wrapper classes with interfaces specific to our different checking algorithms. 1.5. Flexible Reporting HtmlSC allows for different output formats: formats (HTML and text) and destinations (file and console) The reporting subsystem uses the template method pattern to allow different output formats (e.g. Console and HTML). The overall structure of reports is always the same: Graphical clients can use the API of the reporting subsystem to display reports in arbitrary formats. The (generic and abstract) reporting is implemented in the abstract Reporter class as follows: /** * main entry point for reporting - to be called when a report is requested * Uses template-method to delegate concrete implementations to subclasses */ public void reportFindings() { initReport() // (1) reportOverallSummary() // (2) reportAllPages() // (3) closeReport() // (4) } // private void reportAllPages() { pageResults.each { pageResult -&gt; reportPageSummary( pageResult ) // (5) pageResult.singleCheckResults.each { resultForOneCheck -&gt; reportSingleCheckSummary( resultForOneCheck ) // (6) reportSingleCheckDetails( resultForOneCheck ) // (7) reportPageFooter() // (8) } } initialize the report, e.g. create and open the file, copy css-, javascript and image files. create the overall summary, with the overall success percentage and a list of all checked pages with their success rate. iterate over all pages write report footer - in HTML report also create back-to-top-link for a single page, report the nr of checks and problems plus the success rate for every singleCheck on that page, report a summary and all detailed findings for a singleCheck. for every checked page, create a footer, page break or similar to graphically distinguish pages between each other. 1.5.1. Styling the Reporting Output The HtmlReporter explicitly generates css classes together with the html elements, based upon css styling re-used from the Gradle JUnit plugin. Stylesheets, a minimized version of jQuery javascript library plus some icons are copied at report-generation time from the jar-file to the report output directory. Styling the back-to-top arrow/button is done as a combination of JavaScript plus some css styling, as described in https://www.webtipblog.com/adding-scroll-top-button-website/ . 1.5.2. Copy Required Resources to Output Directory When creating the HTML report, we need to copy the required resource files (css, JavaScript) to the output directory. The appropriate copy method was re-used from the Gradle sources . 1.5.3. Attributions Credits for the arrow-icon https://www.iconfinder.com/icons/118743/arrow_up_icon "
},

{
    "id": 18,
    "uri": "arc42/chapters/chap-06-Runtime.html",
    "menu": "arc42",
    "title": "Runtime View",
    "text": " Table of Contents 1. Runtime View 1. Runtime View Note Not appropriate for this system due to very simple implementation. "
},

{
    "id": 19,
    "uri": "arc42/chapters/chap-01-Requirements.html",
    "menu": "arc42",
    "title": "Introduction and Goals",
    "text": " Table of Contents 1. Introduction and Goals 1.1. Requirements Overview 1.2. Quality Goals 1.3. Stakeholder 1.4. Background Information on URIs 1. Introduction and Goals HtmlSC shall support authors creating digital formats with hyperlinks and integration of images and similar resources. 1.1. Requirements Overview The overall goal of HtmlSC is to create neat and clear reports, showing errors within HTML files - as shown in the adjoining figure. 1.1.1. Basic Usage A user configures the location (directory and filename) of one or more HTML file(s), and the corresponding images directory. HtmlSC performs various checks on the HTML and reports its results either on the console or as HTML report. HtmlSC can run from the command line or as Gradle -plugin. Terminology: What Can Go Wrong in HTML Files? Apart from purely syntactical errors, many things can go wrong in html, especially with respect to hyperlinks, anchors and id&#8217;s - as those are often manually maintained. Primary sources of problems are bad links (in technical terms: URIs). For further information, see the background information on URIs . Broken Cross References:: Cross-references (internal links) can be broken, e.g. due to missing or misspelled link-targets. See BrokenCrossReferencesChecker Missing image files: Referenced image files can be missing or misspelled. See MissingImageFilesChecker . Missing local resources: Referenced local resources (other than images) can be missing or misspelled. See MissingLocalResourcesChecker Duplicate link targets: link-targets can occur several times with the same name - so the browser cannot know which is the desired target. See DuplicateIdChecker . Broken external links: External http links can be broken due to myriads of reasons: misspelled, link-target currently offline, illegal link syntax. See BrokenHttpLinksChecker . Missing Alt Attribute in Image Tags: Images missing an alt-attribute. See MissingImgAltAttributeChecker . Checking and reporting these errors and flaws is the central business requirement of HtmlSC . Important terms ( domain terms ) of html sanity checking is documented in a (small) domain model . 1.1.2. General Functionality ID Functionality Description G-1 read HTML file HtmlSC shall read a single (configurable) HTML file G-2 Gradle -plugin HtmlSC can be run as Gradle -plugin. G-3 command line usage HtmlSC can be called from the command line with arguments and options G-4 configurable output output can be configured to console or file G-5 free and open source all required dependencies shall be compliant to the CC-SA-4 licence . G-6 available via public repositories like bintray or jcenter. G-7 configurable to check multiple HTML files configure a set of files to be processes in a single run and produce a joint report. (useful for e.g. API documentation with many HTML files referencing each other) 1.1.3. Types of Sanity Checks ID Check Description R-1 missing image files Check all image tags if the referenced image files exist. See [MissingImageFilesChecker] R-2 broken internal links Check all internal links from anchor-tags (href=#XYZ) if the link targets XYZ are defined. See [BrokenCrossReferencesChecker] R-3 missing local files either other html-files, pdf’s or similar. See [MissingLocalResourcesChecker] R-4 duplicate link targets Check all bookmark definitions (…​ id=XYZ) whether the id’s (XYZ) are unique. See [DuplicateIdChecker] R-5 malformed links Check all links for syntactical correctness R-6 missing alt-attribute in image-tags. See [MissingImgAltAttributeChecker] R-7 unused-images Check for files in image-directories that are not referenced by any of the HTML files in this run R-8 illegal link targets Check for malformed or illegal anchors (link targets). ID Check Description Opt-1 missing external images Check externally referenced images for availability Opt-2 broken external links Check external links for both syntax and availability 1.1.4. Reporting and Output Requirements ID Requirement Description R-1 various output formats Checking output in plain text and HTML R-2 output to stdout HtmlSC can output results on stdout (the console) R-3 configurable file output HtmlSC can store results in file in configurable directories 1.2. Quality Goals Priority Quality-Goal Scenario 1 Correctness Every broken internal link (cross reference) is found. 1 Correctness Every missing local image is found. 2 Flexibility Multiple checking algorithms, report formats and clients. At least Gradle, command-line and a graphical client have to be supported. 2 Safety Content of the files to be checked is never altered. 2 Correctness Correctness of every checker is automatically tested for positive AND negative cases 2 Correctness Every reporting format is tested: Reports must exactly reflect checking results. 3 Performance Check of 100kB html file performed under 10 secs (excluding gradle startup) 1.3. Stakeholder Role Description Goal, Intention Documentation author writes documentation with Html output wants to check that the resulting document contains good links, image references arc42 user uses the arc42 template for architecture documentation wants a small but practical example of how to apply arc42. aim42 contributor contributes to aim42 methode-guide check generated html code to ensure links and images are correct during (gradle-based) build process software developer wants an example of pragmatic architecture documentation and arc42 usage 1.4. Background Information on URIs The generic structure of a Uniform Resource Identifier consists of the following parts: [type][://][subdomain][domain][port][path][file][query][hash] An example, visualized: The java.net.URL class contains a generic parser for URLs and URIs. See the following snippet, taken from the unit test class URLUtilTest.groovy : Generic URI Structure @Test public void testGenericURISyntax() { // based upon an example from the Oracle(tm) Java tutorial: // http://docs.oracle.com/javase/tutorial/networking/urls/urlInfo.html def aURL = new URL(http://example.com:42/docs/tutorial/index.html?name=aim42#INTRO); aURL.with { assert getProtocol() == http assert getAuthority() == example.com:42 assert getHost() == example.com assert getPort() == 42 assert getPath() == /docs/tutorial/index.html assert getQuery() == name=aim42 assert getRef() == INTRO } } URIs are used to reference other resources. For HtmlSC it is useful to distinguish between internal (== local)and external references: Internal references, a.k.a. Cross-References External references 1.4.1. Intra-Document URIs a file&#8230;&#8203; ref can be an internal link, or a URI without protocol&#8230;&#8203; 1.4.2. References on URIs and HTML Syntax IETF RFC-2396 on URI Syntax : The fundamental reference! W3C HTML Reference Wikipedia on URI-Schemes "
},

{
    "id": 20,
    "uri": "arc42/About-This-Docu.html",
    "menu": "arc42",
    "title": "Goals of this Documentation",
    "text": " Table of Contents Goals of this Documentation Disclaimer Goals of this Documentation This documentation is an example of arc42 documentation. You may copy this documentation or parts of it for your own projects. In such cases you must include a link or reference to arc42 or aim42 (we regard this as fair-use ). For real-world projects, the relation of code and documentation is over-sized. Disclaimer We provide absolutely no guarantee , neither for the accuracy of this documentation nor for any property or feature of the software described here. Do not use this software in critical situations or projects. "
},

{
    "id": 21,
    "uri": "arc42/hsc_arc42.html",
    "menu": "-",
    "title": "HTML Sanity Checker Architecture Documentation",
    "text": " Table of Contents HTML Sanity Checker Architecture Documentation Goals of this Documentation Disclaimer 1. Introduction and Goals 1.1. Requirements Overview 1.1.1. Basic Usage Terminology: What Can Go Wrong in HTML Files? 1.1.2. General Functionality 1.1.3. Types of Sanity Checks 1.1.4. Reporting and Output Requirements 1.2. Quality Goals 1.3. Stakeholder 1.4. Background Information on URIs 1.4.1. Intra-Document URIs 1.4.2. References on URIs and HTML Syntax 2. Constraints 3. Context 3.1. Business Context 3.2. Deployment Context 4. Solution Strategy 5. Building Block View 5.1. Whitebox HtmlSanityChecker 5.1.1. HSC Core (Blackbox) 5.2. Building Blocks - Level 2 5.2.1. HSC-Core (Whitebox) 5.2.2. Checker and xyzChecker Subclasses 5.3. Building Blocks - Level 3 5.3.1. ResultsCollector (Whitebox) 6. Runtime View 7. Deployment View 8. Technical and Crosscutting Concepts 8.1. HTML Checking Domain Model 8.2. Gradle Plugin Concept and Development 8.2.1. Directory Structure and Required Files 8.2.2. Passing Parameters From Buildfile to Plugin 8.2.3. Building the Plugin 8.2.4. Uploading to Public Archives 8.2.5. Further Information on Creating Gradle Plugins 8.3. Flexible Checking Algorithms 8.3.1. MissingImageFilesChecker 8.3.2. MissingImgAltAttributeChecker 8.3.3. BrokenCrossReferencesChecker 8.3.4. DuplicateIdChecker 8.3.5. MissingLocalResourcesChecker 8.3.6. BrokenHttpLinksChecker 8.3.7. IllegalLinkChecker 8.4. Encapsulate HTML Parsing 8.5. Flexible Reporting 8.5.1. Styling the Reporting Output 8.5.2. Copy Required Resources to Output Directory 8.5.3. Attributions 9. Design Decisions 9.1. Checking of external links postponed 9.2. HTML Parsing with jsoup 9.3. String Similarity Checking with Jaro-Winkler-Distance 9.4. Glossary HTML Sanity Checker Architecture Documentation &#169; This document uses material from the arc42 architecture template , freely available at https://github.com/arc42 . This material is open source and provided under the Creative Commons Sharealike 4.0 license. It comes without any guarantee . Use on your own risk. arc42 and its structure by Dr. Peter Hruschka and Dr. Gernot Starke. Asciidoc version initiated by Markus Schärtel and Jürgen Krey, completed and maintained by Ralf Müller and Gernot Starke. Version v2.6.7 of 2022-01-14 Note Within the following text, the Html Sanity Checker shall be abbreviated with HtmlSC Goals of this Documentation This documentation is an example of arc42 documentation. You may copy this documentation or parts of it for your own projects. In such cases you must include a link or reference to arc42 or aim42 (we regard this as fair-use ). For real-world projects, the relation of code and documentation is over-sized. Disclaimer We provide absolutely no guarantee , neither for the accuracy of this documentation nor for any property or feature of the software described here. Do not use this software in critical situations or projects. 1. Introduction and Goals HtmlSC shall support authors creating digital formats with hyperlinks and integration of images and similar resources. 1.1. Requirements Overview The overall goal of HtmlSC is to create neat and clear reports, showing errors within HTML files - as shown in the adjoining figure. 1.1.1. Basic Usage A user configures the location (directory and filename) of one or more HTML file(s), and the corresponding images directory. HtmlSC performs various checks on the HTML and reports its results either on the console or as HTML report. HtmlSC can run from the command line or as Gradle -plugin. Terminology: What Can Go Wrong in HTML Files? Apart from purely syntactical errors, many things can go wrong in html, especially with respect to hyperlinks, anchors and id&#8217;s - as those are often manually maintained. Primary sources of problems are bad links (in technical terms: URIs). For further information, see the background information on URIs . Broken Cross References:: Cross-references (internal links) can be broken, e.g. due to missing or misspelled link-targets. See BrokenCrossReferencesChecker Missing image files: Referenced image files can be missing or misspelled. See MissingImageFilesChecker . Missing local resources: Referenced local resources (other than images) can be missing or misspelled. See MissingLocalResourcesChecker Duplicate link targets: link-targets can occur several times with the same name - so the browser cannot know which is the desired target. See DuplicateIdChecker . Broken external links: External http links can be broken due to myriads of reasons: misspelled, link-target currently offline, illegal link syntax. See BrokenHttpLinksChecker . Missing Alt Attribute in Image Tags: Images missing an alt-attribute. See MissingImgAltAttributeChecker . Checking and reporting these errors and flaws is the central business requirement of HtmlSC . Important terms ( domain terms ) of html sanity checking is documented in a (small) domain model . 1.1.2. General Functionality ID Functionality Description G-1 read HTML file HtmlSC shall read a single (configurable) HTML file G-2 Gradle -plugin HtmlSC can be run as Gradle -plugin. G-3 command line usage HtmlSC can be called from the command line with arguments and options G-4 configurable output output can be configured to console or file G-5 free and open source all required dependencies shall be compliant to the CC-SA-4 licence . G-6 available via public repositories like bintray or jcenter. G-7 configurable to check multiple HTML files configure a set of files to be processes in a single run and produce a joint report. (useful for e.g. API documentation with many HTML files referencing each other) 1.1.3. Types of Sanity Checks ID Check Description R-1 missing image files Check all image tags if the referenced image files exist. See MissingImageFilesChecker R-2 broken internal links Check all internal links from anchor-tags (href=#XYZ) if the link targets XYZ are defined. See BrokenCrossReferencesChecker R-3 missing local files either other html-files, pdf’s or similar. See MissingLocalResourcesChecker R-4 duplicate link targets Check all bookmark definitions (…​ id=XYZ) whether the id’s (XYZ) are unique. See DuplicateIdChecker R-5 malformed links Check all links for syntactical correctness R-6 missing alt-attribute in image-tags. See MissingImgAltAttributeChecker R-7 unused-images Check for files in image-directories that are not referenced by any of the HTML files in this run R-8 illegal link targets Check for malformed or illegal anchors (link targets). ID Check Description Opt-1 missing external images Check externally referenced images for availability Opt-2 broken external links Check external links for both syntax and availability 1.1.4. Reporting and Output Requirements ID Requirement Description R-1 various output formats Checking output in plain text and HTML R-2 output to stdout HtmlSC can output results on stdout (the console) R-3 configurable file output HtmlSC can store results in file in configurable directories 1.2. Quality Goals Priority Quality-Goal Scenario 1 Correctness Every broken internal link (cross reference) is found. 1 Correctness Every missing local image is found. 2 Flexibility Multiple checking algorithms, report formats and clients. At least Gradle, command-line and a graphical client have to be supported. 2 Safety Content of the files to be checked is never altered. 2 Correctness Correctness of every checker is automatically tested for positive AND negative cases 2 Correctness Every reporting format is tested: Reports must exactly reflect checking results. 3 Performance Check of 100kB html file performed under 10 secs (excluding gradle startup) 1.3. Stakeholder Role Description Goal, Intention Documentation author writes documentation with Html output wants to check that the resulting document contains good links, image references arc42 user uses the arc42 template for architecture documentation wants a small but practical example of how to apply arc42. aim42 contributor contributes to aim42 methode-guide check generated html code to ensure links and images are correct during (gradle-based) build process software developer wants an example of pragmatic architecture documentation and arc42 usage 1.4. Background Information on URIs The generic structure of a Uniform Resource Identifier consists of the following parts: [type][://][subdomain][domain][port][path][file][query][hash] An example, visualized: The java.net.URL class contains a generic parser for URLs and URIs. See the following snippet, taken from the unit test class URLUtilTest.groovy : Generic URI Structure @Test public void testGenericURISyntax() { // based upon an example from the Oracle(tm) Java tutorial: // http://docs.oracle.com/javase/tutorial/networking/urls/urlInfo.html def aURL = new URL(http://example.com:42/docs/tutorial/index.html?name=aim42#INTRO); aURL.with { assert getProtocol() == http assert getAuthority() == example.com:42 assert getHost() == example.com assert getPort() == 42 assert getPath() == /docs/tutorial/index.html assert getQuery() == name=aim42 assert getRef() == INTRO } } URIs are used to reference other resources. For HtmlSC it is useful to distinguish between internal (== local)and external references: Internal references, a.k.a. Cross-References External references 1.4.1. Intra-Document URIs a file&#8230;&#8203; ref can be an internal link, or a URI without protocol&#8230;&#8203; 1.4.2. References on URIs and HTML Syntax IETF RFC-2396 on URI Syntax : The fundamental reference! W3C HTML Reference Wikipedia on URI-Schemes 2. Constraints HtmlSC shall be: platform-independent and should run on the major operating systems (Windows&#8482;, Linux, and Mac-OS&#8482;) integrated with the Gradle build tool runnable from the command line developed under a liberal open-source license 3. Context 3.1. Business Context Figure 1. Business Context Table 1. Business Context Neighbor Description user documents software with toolchain that generates html. Wants to ensure that links within this html are valid. build system local html files HtmlSC reads and parses local html files and performs sanity checks within those. local image files HtmlSC checks if linked images exist as (local) files. external web resources HtmlSC can be configured to optionally check for the existence of external web resources. Due to the nature of web systems, this check might need a significant amount of time and might yield invalid results due to network and latency issues. 3.2. Deployment Context The following diagram shows the participating computers ({node}) with their technical connections plus the major {artifact} of HtmlSC , the hsc-plugin-binary. Figure 2. Deployment Context Table 2. Deployment Context Node / Artifact Description {node} hsc-development where development of HtmlSC takes place {artifact} hsc-plugin-binary compiled and packaged version of HtmlSC including required dependencies. {node} artifact repository ( Bintray ) global public cloud repository for binary artifacts, similar to mavenCentral . HtmlSC binaries are uploaded to this server. {node} hsc user computer where arbitrary documentation takes place with html as output formats. {artifact} build.gradle Gradle build script configuring (among other things) the HtmlSC plugin to perform the Html checking. Details see deployment view . 4. Solution Strategy Implement HtmlSC in Groovy and Java with minimal external dependencies. Wrap this implementation into a Gradle plugin, so it can be used within automated builds. Details are given in the Gradle plugin concept . Apply the template-method-pattern (see e.g. {template-method-url}) to enable: multiple checking algorithms. See the concept for checking algorithms , both HTML (file) and text (console) output. See the reporting concept . 5. Building Block View 5.1. Whitebox HtmlSanityChecker Rationale We used functional decomposition to separate responsibilities: CheckerCore shall encapsulate checking logic and Html parsing/processing. all kinds of outputs (console, html-file, graphical) shall be handled in a separate component ( Reporter ) Implementation of Gradle specific stuff shall be encapsulated. Contained Blackboxes Table 3. HtmlSanityChecker building blocks HSC Core hsc core: html parsing and sanity checking, configuration, reporting. HSC Gradle Plugin integrates the Gradle build tool with HtmlSC , enabling arbitrary gradle builds to use HtmlSC functionality. HSC Maven Plugin  (planned, not yet implemented) HSC Graphical Interface (planned, not implemented) Interfaces Table 4. HtmlSanityChecker internal interfaces Interface Description usage via shell arc42 user uses a command line shell to call the HtmlSC build system  currently restricted to Gradle: The build system uses HtmlSC as configured in the buildscript. local-file system HtmlSC needs access to several local files, especially the html page to be checked and to the corresponding image directories.  external websites to check external links, HtmlSC needs to access external sites via http HEAD or GET requests. 5.1.1. HSC Core (Blackbox) Intent/Responsibility HSC_Core contains the core functions to perform the various sanity checks. It parses the html file into a DOM-like in-memory representation, which is then used to perform the actual checks. Interfaces Table 5. HSC_Core Interfaces Interface (From-To) Description Command Line Interface &#8594; Checker  Uses the #AllChecksRunner class. Gradle Plugin &#8594; Checker Exposes HtmlSC via a standard Gradle plugin, as described in the Gradle user guide. Files org.aim42.htmlsanitycheck.AllChecksRunner org.aim42.htmlsanitycheck.HtmlSanityCheckGradlePlugin 5.2. Building Blocks - Level 2 5.2.1. HSC-Core (Whitebox) Figure 3. HSC-Core (Whitebox) Rationale This structures follows a strictly functional decomposition: parsing and handling html input checking collecting checking results Contained Blackboxes Table 6. HSC-Core building blocks Checker Abstract class, used in form of the template-pattern. Shall be subclassed for all checking algorithms. AllChecksRunner Facade to the different Checker instances. Provides a (parameter-driven) command-line interface. ResultsCollector (Whitebox) Collects all checking results. Its interface Results is contained in the whitebox description Reporter Reports checking results to either console or an html file. HtmlParser Encapsulates html parsing, provides methods to search within the (parsed) html. Suggester In case of checking issues, suggests alternatives by comparing the faulty element to the one present in the html file. Currently not implemented 5.2.2. Checker and xyzChecker Subclasses The abstract Checker provides a uniform interface ( public void check() ) to different checking algorithms. It is based upon the concept of extensible checking algorithms . 5.3. Building Blocks - Level 3 5.3.1. ResultsCollector (Whitebox) Figure 4. Results Collector (Whitebox) Rationale This structures follows the hierarchy of checks - namely managing results for: a number of pages/documents, containing: a single page, each containing many single checks within a page Contained Blackboxes Table 7. ResultsCollector building blocks Per-Run Results results for potentially many Html pages/documents. Single-Page-Results results for a single page Single-Check-Results results for a single type of check (e.g. missing-images check) Finding a single finding, (e.g. image 'logo.png' missing). Can hold suggestions and (planned for future releases) the responsible html element. Interface Results The Result interface is used by all clients (especially Reporter subclasses, graphical and command-line clients) to access checking results. It consists of three distinct APIs for overall RunResults , single-page results ( PageResults ) and single-check results ( CheckResults ). See the interface definitions below - taken from the Groovy- source code: Interface RunResults public interface RunResults { // returns results for all pages which have been checked public ArrayList&lt;SinglePageResults&gt; getResultsForAllPages() // how many pages were checked in this run? public int nrOfPagesChecked() // how many checks were performed in all? public int nrOfChecksPerformedOnAllPages() // how many findings (errors and issues) were found in all? public int nrOfFindingsOnAllPages() // how long took checking (in milliseconds)? public Long checkingTookHowManyMillis() } Interface PageResults public interface PageResults { // what's the title of this page? public String getPageTitle() // what's the filename and path? public String getPageFileName() public String getPageFilePath() // how many items have been checked? public int nrOfItemsCheckedOnPage() // how many problems were found on this page? public int nrOfFindingsOnPage() // how many different checks have run on this page? public int howManyCheckersHaveRun() } Interface CheckResults public interface CheckResults { // return a description of what is checked // (e.g. Missing Images Checker or Broken Cross-References Checker public String description() // returns all findings/problems found during this check public ArrayList&lt;Finding&gt; getFindings() } 6. Runtime View Note Not appropriate for this system due to very simple implementation. 7. Deployment View Figure 5. Deployment Table 8. Deployment Node / Artifact Description hsc plugin binary compiled version of HtmlSC , including required dependencies. hsc-development where development of HtmlSC takes place artifact repository ( Bintray ) global public cloud repository for binary artifacts, similar to mavenCentral . HtmlSC binaries are uploaded to this server. hsc user computer where arbitrary documentation takes place with html as output formats. build.gradle Gradle build script configuring (among other things) the HtmlSC plugin to check some documentation . The three nodes ( computers ) shown in Deployment are connected via Internet. Sanity checker will: be bundled as a single jar, be uploaded to the Bintray repository, referencable within a gradle buildfile, provide a main method with parameters and options, so all checks can be called from the command line. 8. Technical and Crosscutting Concepts 8.1. HTML Checking Domain Model Figure 6. HTML Checking Domain Model Table 9. Domain Model Term Description Anchor Html element to create &#8594;Links. Contains link-target in the form &lt;a href=link-target&gt; Cross Reference Link from one part of the document to another part within the same document. A special form of &#8594;Internal Link, with a &#8594;Link Target in the same document. External Link Link to another page or resource at another domain. Finding Description of a problem found by one &#8594;Checker within the &#8594;Html Page. Html Element HTML pages (documents) are made up by HTML elements .e.g., &lt;a href=link target&gt; , &lt;img src=image.png&gt; and others. See the W3-Consortium Html Page A single chunk of HTML, mostly regarded as a single file. Shall comply to standard HTML syntax. Minimal requirement: Our HTML parser can successfully parse this page. Contains &#8594;Html Elements. Also called Html Document . id Identifier for a specific part of a document, e.g. &lt;h2 id=#someHeader&gt; . Often used to describe &#8594;Link Targets. Internal Link Link to another section of the same page or to another page of the same domain. Also called Local Link . Link Any a reference in the &#8594;Html Page that lets you display or activate another part of this document (&#8594;Internal Link) or another document, image or resource (can be either &#8594;Internal (local) or &#8594;External Link). Every link leads from the Link Source to the Link Target Link Target The target of any &#8594;Link, e.g. heading or any other a part of a &#8594;Html Document, any internal or external resource (identified by URI). Expressed by &#8594;id Local Resource local file, either other Html files or other types (e.g. pdf, docx) Run Result The overall results of checking a number of pages (at least one page). Single Page Result A collection of all checks of a single &#8594;Html Page. URI Universal Resource Identifier. Defined in RFC-2396 . The ultimate source of truth concerning link syntax and semantic. 8.2. Gradle Plugin Concept and Development You should definitely read the original Gradle User Guide on custom plugin development. To enable the required Gradle integration , we implement a lean wrapper as described in the Gradle user guide. class HtmlSanityCheckPlugin implements Plugin&lt;Project&gt; { void apply(Project project) { project.task('htmlSanityCheck', type: HtmlSanityCheckTask, group: 'Check') } } 8.2.1. Directory Structure and Required Files |-htmlSanityCheck | |-src | | |-main | | | |-org | | | | |-aim42 | | | | | |-htmlsanitycheck | | | | | | | ... | | | | | | |-HtmlSanityCheckPlugin.groovy // (1) | | | | | | |-HtmlSanityCheckTask.groovy | | | |-resources | | | | |-META-INF // (2) | | | | | |-gradle-plugins | | | | | | |-htmlSanityCheck.properties // (3) | | |-test | | | |-org | | | | |-aim42 | | | | | |-htmlsanitycheck | | | | | | | ... | | | | | | |-HtmlSanityCheckPluginTest | the actual plugin code: HtmlSanityCheckPlugin.groovy and HtmlSanityCheckTask.groovy groovy files Gradle expects plugin properties in META-INF property file containing the name of the actual implementation class: implementation-class=org.aim42.htmlsanitycheck.HtmlSanityCheckPlugin 8.2.2. Passing Parameters From Buildfile to Plugin To be done 8.2.3. Building the Plugin The plugin code itself is built with gradle. 8.2.4. Uploading to Public Archives 8.2.5. Further Information on Creating Gradle Plugins Although writing plugins is described in the Gradle user guide, a clearly explained sample is given in a Code4Reference tutorial. 8.3. Flexible Checking Algorithms HtmlSC uses the template-method-pattern to enable flexible checking algorithms: The Template Method defines a skeleton of an algorithm in an operation, and defers some steps to subclasses. &#8212; https://sourcemaking.com/design_patterns/template_method We achieve that by defining the skeleton of the checking algorithm in one operation, deferring the specific checking algorithm steps to subclasses. The invariant steps are implemented in the abstract base class, while the variant checking algorithms have to be provided by the subclasses. Template method performCheck /** ** template method for performing a single type of checks on the given @see HtmlPage. * * Prerequisite: pageToCheck has been successfully parsed, * prior to constructing this Checker instance. **/ public SingleCheckResults performCheck( final HtmlPage pageToCheck) { // assert non-null htmlPage assert pageToCheck != null checkingResults = new SingleCheckResults() // description is set by subclasses initCheckingResultsDescription() return check( pageToCheck ) // &lt;1&gt; delegate check() to subclass } Figure 7. Template-Method Overview Table 10. Template Method Component Description Checker abstract base class, containing the template method check() plus the public method performCheck() MissingImageFilesChecker checks if referenced local image files exist MissingImgAltAttributeChecker checks if there are image tags without alt-attributes BrokenCrossReferencesChecker checks if cross references (links referenced within the page) exist DuplicateIdChecker checks if any id has multiple definitions MissingLocalResourcesChecker checks if referenced other resources exist BrokenHttpLinksChecker checks if external links are valid IllegalLinkChecker checks if links do not violate HTML link syntax 8.3.1. MissingImageFilesChecker Addresses requirement R-1 . Checks if image files referenced in &lt;img src=someFile.jpg&gt; really exists on the local file system. The (little) problem with checking images is their path: Consider the following HTML fragment (from the file testme.html): &lt;img src=./images/one-image.jpg&gt; This image file (one-image.jpg) has to be located relative to the directory containing the corresponding HTML file. Therefore the expected absolute path of the one-image.jpg has to be determined from the absolute path of the html file under test. We check for existing files using the usual Java API, but have to do some directory arithmetic to get the absolutePathToImageFile: File f = new File( absolutePathToImageFile ); if(f.exists() &amp;&amp; !f.isDirectory()) 8.3.2. MissingImgAltAttributeChecker Addresses requirement R-6 . Simple syntactic check: iterates over all &lt;img&gt; tags to check if the image has an alt-tag. 8.3.3. BrokenCrossReferencesChecker Addresses requirement R-2 . Cross references are document-internal links where the href=link-target from the html anchor tag has no prefix like +http, https, ftp, telnet, mailto, file and such. Only links with prefix # shall be taken into account, e.g. &lt;a href=#internalLink&gt;. 8.3.4. DuplicateIdChecker Addresses requirement R-4 . Sections, especially headings, can be made link-targets by adding the id=#xyz element, yielding for example html headings like the following example. Problems occur if the same link target is defined several times (also shown below). &lt;h2 id=seealso&gt;First Heading&lt;/h2&gt; &lt;h2 id=seealso&gt;Second Heading&lt;/h2&gt; &lt;a href=#seealso&gt;Duplicate definition - where shall I go now?&lt;/a&gt; 8.3.5. MissingLocalResourcesChecker Addresses requirement R-3 . Current limitations: Does NOT deep-checking of references-with-anchors of the following form: &lt;a href=api/Artifact.html#target&gt;GroupInit&lt;/a&gt; containing both a local (file) reference plus an internal anchor #target See issues #252 (false positives) and #253 (deep links shall be checked) 8.3.6. BrokenHttpLinksChecker Addresses requirement R-9 . Problem here are networking issues, latency and HTTP return codes. This checker is planned, but currently not implemented. 8.3.7. IllegalLinkChecker Addresses requirement R-5 . This checker is planned, but currently not implemented. :jbake-status: draft :jbake-order: -1 :jbake-type: page_toc :jbake-menu: - :jbake-title: Encapsulate HTML Parsing 8.4. Encapsulate HTML Parsing We encapsulate the third-party HTML parser ( https://jsoup.org ) in simple wrapper classes with interfaces specific to our different checking algorithms. 8.5. Flexible Reporting HtmlSC allows for different output formats: formats (HTML and text) and destinations (file and console) The reporting subsystem uses the template method pattern to allow different output formats (e.g. Console and HTML). The overall structure of reports is always the same: Graphical clients can use the API of the reporting subsystem to display reports in arbitrary formats. The (generic and abstract) reporting is implemented in the abstract Reporter class as follows: /** * main entry point for reporting - to be called when a report is requested * Uses template-method to delegate concrete implementations to subclasses */ public void reportFindings() { initReport() // (1) reportOverallSummary() // (2) reportAllPages() // (3) closeReport() // (4) } // private void reportAllPages() { pageResults.each { pageResult -&gt; reportPageSummary( pageResult ) // (5) pageResult.singleCheckResults.each { resultForOneCheck -&gt; reportSingleCheckSummary( resultForOneCheck ) // (6) reportSingleCheckDetails( resultForOneCheck ) // (7) reportPageFooter() // (8) } } initialize the report, e.g. create and open the file, copy css-, javascript and image files. create the overall summary, with the overall success percentage and a list of all checked pages with their success rate. iterate over all pages write report footer - in HTML report also create back-to-top-link for a single page, report the nr of checks and problems plus the success rate for every singleCheck on that page, report a summary and all detailed findings for a singleCheck. for every checked page, create a footer, page break or similar to graphically distinguish pages between each other. 8.5.1. Styling the Reporting Output The HtmlReporter explicitly generates css classes together with the html elements, based upon css styling re-used from the Gradle JUnit plugin. Stylesheets, a minimized version of jQuery javascript library plus some icons are copied at report-generation time from the jar-file to the report output directory. Styling the back-to-top arrow/button is done as a combination of JavaScript plus some css styling, as described in https://www.webtipblog.com/adding-scroll-top-button-website/ . 8.5.2. Copy Required Resources to Output Directory When creating the HTML report, we need to copy the required resource files (css, JavaScript) to the output directory. The appropriate copy method was re-used from the Gradle sources . 8.5.3. Attributions Credits for the arrow-icon https://www.iconfinder.com/icons/118743/arrow_up_icon 9. Design Decisions 9.1. Checking of external links postponed In the current {revision} we won&#8217;t check external links. These checks have been postponed to later versions. 9.2. HTML Parsing with jsoup To check HTML we parse it into an internal (DOM-like) representation. For this task we use jsoup HTML parser , an open-source parser without external dependencies. To quote from the jsoup website: jsoup is a Java library for working with real-world HTML. It provides a very convenient API for extracting and manipulating data, using the best of DOM, CSS, and jQuery-like methods. Goals of this decision Check HTML programmatically by using an existing API that provides access and finder methods to the DOM-tree of the file(s) to be checked. Decision Criteria few dependencies, so the HtmlSC binary stays as small as possible. accessor and finder methods to find images, links and link-targets within the DOM tree. Alternatives HTTPUnit: a testing framework for web applications and -sites. Its main focus is web testing and it suffers from a large number of dependencies. jsoup: a plain HTML parser without any dependencies (!) and a rich API to access all HTML elements in DOM-like syntax. Find details on how HtmlSC implements HTML parsing in the HTML encapsulation concept . 9.3. String Similarity Checking with Jaro-Winkler-Distance The small java-string-similarity library (by Ralph Allen Rice) contains implementations of several similarity-calculation algorithms. As it is not available as public binary, we use the sources instead, primarily: net.ricecode.similarity.JaroWinklerStrategyTest net.ricecode.similarity.JaroWinklerStrategy Note The actual implementation of the similarity comparison has been postponed to a later release of HtmlSC 9.4. Glossary See the domain model for explanations of important terms. "
},

{
    "id": 22,
    "uri": "search.html",
    "menu": "-",
    "title": "search",
    "text": " Search Results "
},

{
    "id": 23,
    "uri": "lunrjsindex.html",
    "menu": "-",
    "title": "null",
    "text": " will be replaced by the index "
},

];
